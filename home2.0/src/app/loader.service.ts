import { Injectable } from '@angular/core';
import { Http, HttpModule, Headers, URLSearchParams } from '@angular/http';
import 'rxjs/add/operator/toPromise';
import { mapValues, keys, mapKeys, values, trim, uniq, toPairs } from 'lodash';
import { DomSanitizer, SafeResourceUrl, SafeHtml } from '@angular/platform-browser';
import * as _ from 'lodash';
import * as d3 from 'd3';
import * as bibtexParser from 'bibtex-parser';

// can be customised to be sensitive to target.
// pass in function that will generate keys for the cache:
// e.g. if values varies on multiple parameters, then return
// a concatenation of dependent values
export let memoize = (f: (...args: any[]) => string) => {
  return function (target: Object, propertyKey: string, descriptor: TypedPropertyDescriptor<any>) {
    const retval: { [method: string]: any } = {}, method = descriptor.value;
    descriptor.value = function (...args: any[]) {
      const cache_key = propertyKey + (f !== undefined) ? '_' + f.apply(null, args) : '';
      if (retval[cache_key]) {
        return retval[cache_key];
      }
      return retval[cache_key] = method.apply(this, args);
    };
  };
}

/* generated by pandoc */
export class Author {
  family: string;
  given: string;
}

enum EntryType {
  article, // = 'ARTICLE',
  inproc, // .. = 'INPROCEEDINGS',
  misc, // = 'MISC',
  techreport, // = 'TECHREPORT',
  phdthesis//  = 'PHDTHESIS'
}

export class BibEntry {
  author: Author[];
  entrytype: EntryType;
  title: string;
  booktitle?: string;
  year?: string;
  organization?: string;
  publisher?: string;
  // type: string;
  // containerTitle?: string;
  // issued?: ({ [key: string]: number[][] });
}

export class Project {
  id: string;
  title: string;
  theme: string;
  pubs: string[];
  pubsbibtex: BibEntry[];
  images: string[];
  headimg: string;
  color: string;
  summary: string;
  summaryHtml: SafeHtml;
}

export class NewsItem {
  id: string;
  datestr: string;
  date: Date;
  summary: string;
  summaryHtml: SafeHtml;
}


@Injectable()
export class LoaderService {

  constructor(private httpM: HttpModule, private http: Http, private sanitiser: DomSanitizer) {
    this.getBibTex();
  }

  @memoize((x) => x)
  getPubs(): Promise<BibEntry[]> {
    return this.http.get('assets/bibtex.json').toPromise().then(response => {
      return response.json().map(this._inPub);
    });
  }

  @memoize((x) => x)
  getBibTex(): Promise<{[x: string]: BibEntry}> {
    return this.http.get('assets/bibtex.bib').toPromise().then(response => {
      let parsed = bibtexParser(response.text()) as {[key: string]: BibEntry};
      _.mapValues(parsed, (p) => {
        if (p.AUTHOR) {
          // split authors
          p.AUTHOR = p.AUTHOR.split(' and ').map((name) => ({ family: name.split(',')[0], given: name.split(', ')[1] }));
        }
      });
      parsed = _.mapKeys(parsed, (v, k) => {
        return k.toLowerCase();
      });
      parsed = _.mapValues(parsed, (v, k) => {
        v = _.mapKeys(v, (vv, kk) => kk.toLowerCase());
        return _.mapValues(v, (vv, kk) => {
          if (typeof vv === 'string') {
              // gets rid of accents in values
              return vv.replace(/\{\\\'(.)\}/g, '$1').replace(/\\(.)/g, '$1');
          }
          // now let's get rid of accents in authors, like paul andr√© <3
          if (kk === 'author') {
              return vv.map((author) => _.mapValues(author, (vva, kka) => vva && vva.replace(/\{\\\'(.)\}/g || '', '$1')));
          }
          if (kk === 'title') {
            if ('.?!'.indexOf(kk.slice(-1)[0]) < 0) {
              return vv + '.';
            }
          }
          return vv;
        });
      });
      console.log(parsed);
      return parsed;
    });
  }


  _inPub(ii): BibEntry {
    return _.mapKeys(ii, (v, k) => {
      return _.map(k.split('-'), (kword, i) => i > 0 ? kword.toUpperCase() : kword).join('');
    }) as BibEntry;
  }

  getProjects(): Promise<Project[]> {
    return this.getBibTex().then((by_bibid) => {
      return this.http.get('assets/proj.json').toPromise().then(response => {
        return response.json().projects as Project[];
      }).then((ps) => {
        ps.map((p) => {
          p.color = d3.interpolateRainbow(1.0 * ps.indexOf(p)/ps.length);
          if (p.summary) { 
            p.summary = ['<p>', p.summary.replace(/\n/g, '</p><p>'), '</p>'].join('');
            p.summaryHtml = this.sanitiser.bypassSecurityTrustHtml(p.summary);
          }
          if (p.pubs) {
            p.pubsbibtex = p.pubs.map((pubid) => by_bibid[pubid] || undefined).filter((x) => x);
          }
          (window as any).d3 = d3;
        });
        return ps;
      });
    });
  }

  getNews(): Promise<NewsItem[]> {
    return this.http.get('assets/news.json').toPromise().then(response => {
      return response.json().news as NewsItem[];
    }).then((news) => {
      news.map((n) => {
        n.date = new Date(n.datestr);
        n.summaryHtml = this.sanitiser.bypassSecurityTrustHtml(n.summary);
      });
      news.sort((a, b) => b.date.valueOf() - a.date.valueOf());
      return news;
    });
  }
}
